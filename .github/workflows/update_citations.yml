name: ManUpdate  # Manually update dataset citations

on:
  workflow_dispatch: # Allows manual triggering

# Permissions needed for creating pull requests
permissions:
  contents: write
  pull-requests: write

jobs:
  update_citations_job:
    runs-on: ubuntu-latest
    name: Discover  # Discover datasets and update citations

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          # Fetch all history so branches can be properly updated
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v3
        with:
          python-version: '3.10' # Specify Python version

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Setup GitHub CLI
        run: |
          echo "Checking for gh CLI..."
          if ! command -v gh &> /dev/null
          then
              echo "gh CLI not found, attempting to install using official script..."
              # Official gh installation script for Debian/Ubuntu based systems
              (type -p wget >/dev/null || (sudo apt-get update -yq && sudo apt-get install wget -yq)) \
              && sudo mkdir -p -m 755 /etc/apt/keyrings \
              && out=$(mktemp) && wget -nv -O$out https://cli.github.com/packages/githubcli-archive-keyring.gpg \
              && cat $out | sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg > /dev/null \
              && sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg \
              && echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
              && sudo apt-get update -yq \
              && sudo apt-get install gh -yq

              if ! command -v gh &> /dev/null; then echo "::error::Failed to install/verify gh CLI after using official script."; exit 1; fi
              echo "gh CLI installed successfully using official script."
          else
              echo "gh CLI already found. Checking version to ensure it's recent enough..."
              # Optional: Add a version check here if pre-installed gh could be too old
              # For now, we assume if it's found, it might be okay, or the install block would have run.
          fi

          echo "Authenticating gh CLI..."
          # secrets.GITHUB_TOKEN should be available here if .secrets is used with act
          gh auth login --with-token <<< "${{ secrets.GITHUB_TOKEN }}"
          echo "Setting up Git with gh CLI authentication..."
          gh auth setup-git # Configures git to use gh as a credential helper
          
          echo "Verifying gh auth status..."
          gh auth status # This will show how gh is authenticated

          echo "Checking gh CLI version..."
          gh --version

          echo "Determining repository from git remote..."
          REMOTE_URL=$(git config --get remote.origin.url)
          # Try to extract owner/repo from HTTPS URL
          REPO_SLUG=$(echo "$REMOTE_URL" | sed -n 's|https://github.com/\([^/]*\/[^.]*\)\.git$|\1|p')
          
          if [ -z "$REPO_SLUG" ]; then
            # Try to extract owner/repo from SSH URL
            REPO_SLUG=$(echo "$REMOTE_URL" | sed -n 's|git@github.com:\([^/]*\/[^.]*\)\.git$|\1|p')
          fi

          if [ -n "$REPO_SLUG" ]; then
              echo "Setting default repository for gh CLI to: $REPO_SLUG"
              gh repo set-default "$REPO_SLUG"
          else
              echo "::warning::Could not automatically determine repository from remote URL ('$REMOTE_URL'). You may need to set it manually for act if gh commands fail."
              # Fallback if really needed for act AND if the slug is static:
              # echo "Falling back to hardcoded repository: neuromechanist/dataset_citations"
              # gh repo set-default "neuromechanist/dataset_citations"
          fi
          echo "gh CLI setup complete."

      - name: Configure Git User Identity
        run: |
          git config --global user.name "citations-bot"
          git config --global user.email "shirazi@ieee.org"
          echo "Git user identity configured successfully"

      - name: Create or switch to update branch
        id: create_branch
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Generate branch name with current year and month
          BRANCH_NAME="auto-update/$(date +'%Y-%m')"
          echo "Using branch name: $BRANCH_NAME"
          
          # Check if branch exists locally
          if git show-ref --quiet refs/heads/$BRANCH_NAME; then
            echo "Branch $BRANCH_NAME already exists locally, checking out"
            git checkout $BRANCH_NAME
          else
            # Check if branch exists on remote
            # if git ls-remote --heads origin $BRANCH_NAME | grep -q $BRANCH_NAME; then
            #   echo "Branch $BRANCH_NAME exists on remote, checking out"
            #   git fetch origin $BRANCH_NAME
            #   git checkout $BRANCH_NAME
            # else
            echo "Creating new branch $BRANCH_NAME"
            git checkout -b $BRANCH_NAME
            # fi
          fi
          
          # Make branch name available to subsequent steps
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Discover relevant datasets
        id: discover
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Or a specific PAT if needed
        run: |
          echo "Discovering relevant datasets..."
          python discover_datasets.py --output-file discovered_datasets.txt
          echo "dataset_list_file=discovered_datasets.txt" >> $GITHUB_OUTPUT

      - name: Update citation information
        id: update_citations
        env:
          SCRAPERAPI_KEY: ${{ secrets.SCRAPERAPI_KEY }}
        run: |
          python update_citations.py \
            --dataset-list-file ${{ steps.discover.outputs.dataset_list_file }} \
            --previous-citations-file citations/previous_citations.csv \
            --output-dir citations_output/ \
            --workers 5

      - name: Update previous_citations.csv for next run
        id: update_previous
        run: |
          echo "Looking for today's citation file to update previous_citations.csv..."
          TODAY_DATE=$(date +%d%m%Y)
          LATEST_CITATIONS_FILE="citations_output/citations_${TODAY_DATE}.csv"
          TARGET_PREVIOUS_FILE="citations/previous_citations.csv"

          if [ -f "$LATEST_CITATIONS_FILE" ]; then
            echo "Found $LATEST_CITATIONS_FILE. Copying to $TARGET_PREVIOUS_FILE..."
            # Ensure the target directory exists, though it should from checkout
            mkdir -p citations/
            cp "$LATEST_CITATIONS_FILE" "$TARGET_PREVIOUS_FILE"
            echo "Successfully updated $TARGET_PREVIOUS_FILE"
          else
            echo "Error: Today's citation file ($LATEST_CITATIONS_FILE) not found."
            echo "Skipping update of $TARGET_PREVIOUS_FILE. It might need to be created manually or the script might not have run as expected."
            # Consider whether this should be a failing condition
            # exit 1 
          fi

      - name: Check for changes
        id: check_changes
        run: |
          # Refresh Git status to detect new or modified files
          git add -A
          
          # Check if there are any unstaged changes in the citations and citations_output directories
          if ! git diff --cached --quiet -- citations/ citations_output/; then
            echo "CHANGES_DETECTED=true" >> $GITHUB_ENV
            echo "changes_detected=true" >> $GITHUB_OUTPUT
            
            # Count changed files for reporting
            CHANGED_FILES=$(git diff --cached --name-only -- citations/ citations_output/ | grep -E '\.(csv|pkl|txt)$' | wc -l)
            echo "CHANGED_FILES=$CHANGED_FILES" >> $GITHUB_ENV
            echo "changed_files=$CHANGED_FILES" >> $GITHUB_OUTPUT
            
            # List changed files for the commit message
            CHANGED_FILES_LIST=$(git diff --cached --name-only -- citations/ citations_output/ | grep -E '\.(csv|pkl|txt)$')
            echo "CHANGED_FILES_LIST<<EOF" >> $GITHUB_ENV
            echo "$CHANGED_FILES_LIST" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            
            echo "Detected $CHANGED_FILES changed files in citations and citations_output directories"
          else
            echo "CHANGES_DETECTED=false" >> $GITHUB_ENV
            echo "changes_detected=false" >> $GITHUB_OUTPUT
            echo "No changes detected in citations or citations_output directories"
          fi

      - name: Display change detection results
        run: |
          if [ "${{ env.CHANGES_DETECTED }}" == "true" ]; then
            echo "Found changes in the following files:"
            echo "${{ env.CHANGED_FILES_LIST }}"
            echo "Total changed files: ${{ env.CHANGED_FILES }}"
          else
            echo "No changes were detected in citation files."
            echo "Skipping commit stage."
          fi

      - name: Commit changes
        id: commit
        if: ${{ env.CHANGES_DETECTED == 'true' && steps.update_citations.outcome == 'success' && steps.update_previous.outcome == 'success' }}
        run: |
          # Stage all changes for commit
          git add citations/ citations_output/
          
          # Create a descriptive commit message
          COMMIT_DATE=$(date +'%Y-%m-%d')
          WORKFLOW_RUN="${{ github.workflow }} #${{ github.run_number }}"
          
          # Create multi-line commit message with details
          cat > commit_message.txt << EOF
          Update dataset citations - $COMMIT_DATE
          
          Workflow: $WORKFLOW_RUN
          Run ID: ${{ github.run_id }}
          Updated files: ${{ env.CHANGED_FILES }}
          
          Changed files:
          ${{ env.CHANGED_FILES_LIST }}
          EOF
          
          # Commit with the descriptive message
          if ! git commit -F commit_message.txt; then
            echo "::error::Failed to commit changes"
            exit 1
          fi
          
          echo "Changes committed successfully with descriptive message"
          echo "Commit message:"
          cat commit_message.txt

      - name: Push changes
        id: push
        if: ${{ success() && env.CHANGES_DETECTED == 'true' && steps.commit.outcome == 'success' }}
        run: |
          # Try to push changes, with retry logic
          MAX_RETRIES=3
          RETRY_COUNT=0
          PUSH_SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Attempting to push changes to origin/${{ env.BRANCH_NAME }} (attempt $((RETRY_COUNT+1)) of $MAX_RETRIES)..."
            
            if git push origin ${{ env.BRANCH_NAME }}; then
              echo "Changes pushed successfully to ${{ env.BRANCH_NAME }}"
              PUSH_SUCCESS=true
              break
            else
              RETRY_COUNT=$((RETRY_COUNT+1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Push failed, retrying in 10 seconds... (Attempt $RETRY_COUNT of $MAX_RETRIES)"
                sleep 10
                
                # Fetch latest changes before retry
                echo "Fetching latest changes from origin/${{ env.BRANCH_NAME }}..."
                git fetch origin ${{ env.BRANCH_NAME }}
                
                # Check if we need to rebase
                if git rev-parse origin/${{ env.BRANCH_NAME }} >/dev/null 2>&1; then
                  echo "Rebasing with latest changes from origin/${{ env.BRANCH_NAME }}..."
                  if ! git rebase origin/${{ env.BRANCH_NAME }}; then
                    echo "Rebase failed. Aborting rebase and trying merge instead..."
                    git rebase --abort
                    git merge origin/${{ env.BRANCH_NAME }}
                  fi
                fi
              else
                echo "::error::Failed to push changes after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done
          
          if [ "$PUSH_SUCCESS" = true ]; then
            echo "push_successful=true" >> $GITHUB_OUTPUT
            echo "PUSH_SUCCESSFUL=true" >> $GITHUB_ENV
          else
            echo "push_successful=false" >> $GITHUB_OUTPUT
            echo "PUSH_SUCCESSFUL=false" >> $GITHUB_ENV
          fi

      - name: Handle push failure
        if: ${{ failure() && steps.push.outcome == 'failure' }}
        run: |
          echo "Push operation failed. Please check the logs for details."
          echo "You may need to manually push the commits or resolve conflicts."
          # Could send notification or create an issue here

      - name: Generate dynamic PR content
        id: pr-content
        if: ${{ success() && env.CHANGES_DETECTED == 'true' && steps.push.outcome == 'success' }}
        run: |
          # Find the updated citation file to compare with the previous one
          TODAY_DATE=$(date +%d%m%Y)
          LATEST_CITATIONS_FILE="citations_output/citations_${TODAY_DATE}.csv"
          PREVIOUS_CITATIONS_FILE="citations/previous_citations.csv"
          
          # Generate dynamic PR content using our Python script
          python scripts/generate_pr_content.py \
            --previous-file "$PREVIOUS_CITATIONS_FILE" \
            --current-file "$LATEST_CITATIONS_FILE" \
            --format github \
            --repo-url "${{ github.server_url }}/${{ github.repository }}"
          
          echo "PR content generated successfully"

      - name: Create Pull Request with gh CLI
        id: create-pr
        if: ${{ success() && env.CHANGES_DETECTED == 'true' && steps.push.outcome == 'success' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH_NAME: ${{ env.BRANCH_NAME }}
          PR_TITLE: ${{ steps.pr-content.outputs.pr_title || 'Update dataset citations' }}
          PR_BODY: ${{ steps.pr-content.outputs.pr_body || 'This PR updates the dataset citation database.' }}
          PR_LABELS: ${{ steps.pr-content.outputs.pr_labels || 'automated,citation-update' }}
        run: |
          echo "Attempting to create Pull Request for branch: $BRANCH_NAME"
          gh pr create \
            --base main \
            --head "$BRANCH_NAME" \
            --title "$PR_TITLE" \
            --body "$PR_BODY" \
            --label "$PR_LABELS" \
            --repo "${{ github.repository }}"
          echo "gh pr create command executed."

      - name: PR Creation Status
        if: ${{ success() && env.CHANGES_DETECTED == 'true' && steps.push.outcome == 'success' && steps.create-pr.outcome == 'success' }}
        run: |
          echo "Pull Request creation attempt using gh CLI finished. Review logs from 'Create Pull Request with gh CLI' step for URL and details."

# Removing the old PR Creation Result step that will no longer work
# - name: PR Creation Result
#   if: ${{ env.CHANGES_DETECTED == 'true' && steps.create-pr.outcome == 'success' }}
#   run: |
#     echo "Pull request created successfully!"
#     echo "PR URL: ${{ steps.create-pr.outputs.pull-request-url }}" 